<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[散列]]></title>
    <url>%2F2017%2Fhash%2F</url>
    <content type="text"><![CDATA[散列表的实现常常叫做散列(hashing)。散列是一种用于以常数平均时间执行插入、删除和查找的技术。但是，那些需要元素间任何排序信息的树操作将不会得到有效的支持。]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[表、栈和队列]]></title>
    <url>%2F2017%2Fadt%2F</url>
    <content type="text"><![CDATA[ADT抽象数据类型(abstract data type,ADT)是带有一组操作的对象的集合。对于集合ADT，可以有添加、删除、包含等操作 表ADT简单数组实现对表的所有操作都可以通过使用数组来实现。虽然数组是有固定容量创建的，但在需要的时候可以使用双倍的容量创建一个不同的数组。许多情形下表是通过在末端进行插入操作的，然后只对数组访问。这种情形下数组是一种恰当的实现。然而如果发生一些插入和删除操作，特别是前端进行，那么数组不是一种好的选择。 简单链表为了避免插入和删除的线性开销，需要保证表可以不连续存储，否则表的每个部分都可能需要整体移动。链表是由一系列的节点组成，这些节点不必在内存中相连，每个节点含有表元素和到包含该元素后继元素的节点的链，可以称之为next链，最后一个单元的next链引用null。简单链表删除最后一项比较复杂，因为必须找出指向最后节点的项，把它的next链改成null，然后在更新持有最后节点的链，最好的做法是让每一个节点有一个指向它在表中的前面节点的链称之为双链表 java Collection API中的表Collection接口 Collection接口扩展了Iterable接口，实现Iterable接口的类拥有增强for循环，都可以使用forEach进行循环遍历123456789public interface Collection&lt;E&gt; extends Iterable&lt;E&gt; &#123; int size(); boolean isEmpty(); void clear(); boolean contains(Object o); Iterator&lt;E&gt; iterator(); boolean add(E e); boolean remove(Object o); &#125; Iterator接口1234567public interface Iterator&lt;E&gt; &#123; boolean hasNext(); E next(); default void remove() &#123; throw new UnsupportedOperationException(&quot;remove&quot;); &#125;&#125; Iterator的remove方法主要优点在于：Collection的remove方法必须先找出需要删除的项。在迭代集合时Collection的remove会抛出ConcurrentModificationException 增强for循环java中的增强for循环实际上编译器会重写成如下所示：1234567891011List&lt;String&gt; list = new ArrayList&lt;&gt;();list.add("abc");for (String s : list) &#123; System.out.println(s);&#125;//等同于上面增强for循环写法Iterator&lt;String&gt; it = list.iterator();while (it.hasNext()) &#123; String s = it.next(); System.out.println(s);&#125; List接口、ArrayList类和LinkedList类1、ArrayList类提供了list ADT的一种可增长数组的实现，其优点在于对get和set的调用花费常数时间，其缺点是插入和删除代价昂贵（除了在末端进行）。2、LinkedList类提供了list ADT的双链表实现，其优点是插入和删除均开销很小，在表的前端和末端添加和删除都是常数时间的操作，其缺点是不容易索引，get的调用是昂贵的（除了get第一个和最后一个）。3、对搜索而言，ArrayList和LinkedList都是低效的，对Collection的contains和remove方法的调用均花费线性时间。4、ArrayList中有个容量的概念，它标识基础数组的大小，在需要的时候会自动扩容保证至少具有表的大小，如果早期知道该大小，可以设置容量足够大的量以避免数组容量以后的扩展，trimToSize可以在所有的ArrayList添加操作完成之后使用以避免浪费空间。5、以下方法对于LinkedList操作整个程序线性时间不是二次时间，对于ArrayList是二次时间，因为对于ArrayList即使迭代器位于需要被删除的节点上，其remove方法仍然是昂贵的，因为数组的项必须要移动12345678public static void remove(List&lt;Integer&gt; list) &#123; Iterator&lt;Integer&gt; iterator = list.iterator(); while (iterator.hasNext()) &#123; if (iterator.next() % 2 == 0) &#123; iterator.remove(); &#125; &#125; &#125; ListIterator接口ListIterator扩展了Iterator接口。1、iterator可以应用于所有的集合，Set、List和Map以及这些集合的子类型。而ListIterator只能用于List及其子类型。2、ListIterator有hasPrevious()和previous()方法，可以实现逆向遍历，但是iterator不可以。3、ListIterator可以定位当前索引的位置，nextIndex()和previousIndex()可以实现。Iterator没有此功能。4、ListIterator有add方法，可以向List中添加对象，而Iterator不能。5、ListIterator可以实现对象的修改，set()方法可以实现。Iterator仅能遍历，不能实现修改。都可以实现删除操作。用例：它可以用来从List的所有的偶数中减去1，对于LinkedList来说，不适用ListIterator的set方法是很难做到的。 简单的ArrayList类的实现只供参考理解，编译器会报错123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111public class MyArrayList&lt;AnyType&gt; implements Iterable&lt;AnyType&gt; &#123; private static final int DEFAULT_CAPACITY = 10; private int theSize; private AnyType[] theItems; public int size() &#123; return theSize; &#125; public boolean isEmpty() &#123; return size() == 0; &#125; //调整容量符合大小 public void trimToSize() &#123; ensureCapacity(size()); &#125; //确保数组大小足够大 public void ensureCapacity(int newCapacity) &#123; if(newCapacity &lt; theSize) return; //复制数据到新数组中 AnyType[] old = theItems; theItems = (AnyType[]) new Object[newCapacity]; for(int i = 0; i &lt;size(); i++) &#123; theItems[i] = old[i]; &#125; &#125; public AnyType get(int index) &#123; if(index &lt; 0 || index &gt;= size()) &#123; throw new ArrayIndexOutOfBoundsException(); &#125; return theItems[index]; &#125; public AnyType set(int index, AnyType newVal) &#123; if(index &lt; 0 || index &gt;= size()) &#123; throw new ArrayIndexOutOfBoundsException(); &#125; AnyType old = theItems[index]; theItems[index] = newVal; return old; &#125; public void add(int index, AnyType x) &#123; //数组不够大，则扩大数组 if(theItems.length == size()) &#123; ensureCapacity(size()*2 + 1); &#125; //从index开始，元素往后移动一位 for(int i = theSize; i &gt; index; i--) &#123; theItems[i] = theItems[i - 1]; &#125; //index位置赋值x theItems[index] = x; theSize++; &#125; public AanyType remove(int index) &#123; AnyType removedItem = theItems[index]; for(int i = index; i &lt; size(); i++) &#123; //从index位置开始，所有元素都往前移动一位 theItems[i] = theItems[i + 1]; &#125; theSize--; return removedItem; &#125; public java.util.Iterator&lt;AnyType&gt; iterator() &#123; return new ArrayListIterator&lt;AnyType&gt;(); &#125; private static class ArrayListIterator&lt;AnyType&gt; implements java.util.Iterator&lt;AnyType&gt; &#123; private int current = 0; public boolean hasNext() &#123; return current &lt; MyArrayList.this.size(); &#125; public AnyType next() &#123; return MyArrayList.this.theItems[current++]; &#125; public void remove() &#123; //防止迭代器的remove与MyArrayList的remove冲突 MyArrayList.this.remove(--current); &#125; &#125; &#125;; 简单的LinkedList类的实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176public class MyLinkedList &lt;AnyType&gt; implements Iterable&lt;AnyType&gt;&#123; private int theSize; //双向链表中的元素个数 private int modCount; //这个标记为了配合Iterator实现修改的保护，这一点后面专做论述,凡是做了增删修改，这个标记均变化 private Node&lt;AnyType&gt; beginMarker; // 双向链表的开始标记 private Node&lt;AnyType&gt; endMarker; //双向链表的尾部标记 public MyLinkedList() &#123; // 构造函数 先初始化双向聊表 调动 clear()函数 clear(); &#125; public void clear() &#123;// 确保双向链表处于空的状态 ----&gt; 我们使用一个辅助的头结点 // 头标记和尾标记 指向同一个 辅助头结点,和一个辅助的尾节点 beginMarker = new Node&lt;AnyType&gt;(null, null, null); endMarker = new Node&lt;AnyType&gt;(null, beginMarker, null); beginMarker.next = endMarker; theSize = 0; modCount ++; //zhege &#125; // 获取元素的个数 public int size() &#123; return theSize; &#125; // 判断是否为空 public boolean isEmpty() &#123; return theSize == 0; &#125; /* * 增删查改的操作 */ // 默认把元素插入到尾部,其中调用插入到指定位置的函数 public boolean add(AnyType x) &#123; add(size()+1, x); return true; &#125; // 把元素插入到指定位置，其中调用插入到指定元素之前 函数 public void add(int idx, AnyType x) &#123; addBefore(getNode(idx), x); &#125; // 重置某个节点的data值，并返回以前的 data值 public AnyType set(int idx, AnyType newVal) &#123; if(idx &lt;1 || idx &gt;size()) throw new RuntimeException(new Exception("下表越界")); Node&lt;AnyType&gt; p = getNode(idx); AnyType oldVal = p.data; p.data = newVal; return oldVal; &#125; // 删除第idx个节点,调用remove(Node)函数，返回删除节点的data值 public AnyType remove(int idx) &#123; if(idx &lt;1 || idx &gt;size()) throw new RuntimeException(new Exception("下表越界")); return remove(getNode(idx)); &#125; /* * 下面这些函数都是一些private的都是位别的一些函数服务的 */ // 在p前面插入 x 元素 private void addBefore(Node&lt;AnyType&gt;p, AnyType x) &#123; Node&lt;AnyType&gt; newNode = new Node&lt;AnyType&gt;(x, p.prev, p); newNode.prev.next = newNode; p.prev = newNode; theSize ++; //添加进来一个新元素之后，别忘了元素个数++ modCount ++; //无论增删 该标志 均++ &#125; // 获取 idx处的 节点引用 private Node&lt;AnyType&gt; getNode(int idx) &#123; if(idx &lt; 1 || idx &gt; size()+1)// 考虑在尾部插入的情况，如果取这个尾节点，其data = null throw new RuntimeException(new Exception("索引越界")); Node&lt;AnyType&gt; p = null; if( idx &lt;= size()/2) // 在前半边中找 &#123; p = beginMarker.next; for( int i = 1; i &lt; idx; i++) p = p.next; &#125;else&#123; //在后半边中找 p = endMarker; for(int i = size(); i &gt;= idx; i--) p = p.prev; &#125; return p; &#125; // 返回 删除某个节点，并返回这个节点的data值 private AnyType remove(Node&lt;AnyType&gt; p) &#123; p.prev.next = p.next; p.next.prev = p.prev; theSize --; modCount --; return p.data; &#125; /* * 实现迭代器 */ public Iterator&lt;AnyType&gt; iterator() &#123; return new LinkedListIterator(); &#125; //实现迭代器 private class LinkedListIterator implements Iterator&lt;AnyType&gt; &#123; private Node&lt;AnyType&gt; current = beginMarker.next; //记住当前的位置，这和书序表中类似 private int expectedModCount = modCount; private boolean okToRemove = false; @Override public boolean hasNext() &#123; // TODO Auto-generated method stub return current!=endMarker; &#125; @Override public AnyType next() &#123; // 注意了 下面的 保护迭代期间 不允许 越过迭代器修改集合元素的 机制 是精髓 if(modCount != expectedModCount) throw new RuntimeException(new Exception("您刚刚越过迭代器修改了集合元素")); if(!hasNext()) throw new RuntimeException(new Exception("已经没有元素了")); AnyType nextItem = current.data; current = current.next; okToRemove = true; return nextItem; &#125; @Override public void remove() &#123; // TODO Auto-generated method stub if(modCount != expectedModCount) throw new RuntimeException(new Exception("您刚刚越过迭代器修改了集合元素")); if(!okToRemove) throw new RuntimeException(new Exception("先next再删除")); MyLinkedList.this.remove(current.prev); okToRemove = false; // 与next()中的 okToRemove = false； 遥相呼应，以确保必须在next()之后才能remove expectedModCount ++; &#125; &#125; /* * 私有嵌套类的形式，定义内部节点，节点里面没有访问双向链表中的内容，所以使用私有嵌套类可也 * 如果访问了外面类的属性或者方法就只能使用内部类，去除static关键字,内部类的使用主要是为了可以简写，见单链表中的介绍 */ private static class Node&lt;AnyType&gt;&#123; // 构造函数 public Node(AnyType d, Node&lt;AnyType&gt;p, Node&lt;AnyType&gt;n) &#123; data = d; prev = p; next = n; &#125; public AnyType data; public Node&lt;AnyType&gt; prev; public Node&lt;AnyType&gt; next; &#125; &#125; 栈栈(stack)是限制插入和删除只能在一个位置上进行的表，该位置是表的末端，叫做栈的顶端(top),对栈的操作有push(进栈)和pop(出栈)，前者相对于插入，后者相对于删除最后插入的元素。栈有时又叫做LIFO(后进先出)表。 栈的实现由于栈是一个表，任何实现表的方法都能实现栈，ArrayList和LinkedList都支持栈操作 栈的应用简单例子：平衡符号：编译器检查程序的语法错误叙述如下：做一个空栈，读入字符知道文件结尾，如果字符是个开放符号则将其推入栈中，如果是个封闭符号则当栈空时报错，否则将栈元素弹出，如果弹出的符号不是对应的开放符号则报错，在文件结尾如果栈非空则报错。 队列队列也是表，使用队列时，插入在一段，删除则在另一端。队列的基本操作是enqueue(入队)，它在表的末端插入元素，和dequeue(出队)，它删除并返回在表的开头的元素 队列的实现如果栈的情形一样，对于队列而言任何的表的实现都是合法的 队列的应用窗口买票的应用等所有需要先进先出的案例]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[树]]></title>
    <url>%2F2017%2Ftree%2F</url>
    <content type="text"><![CDATA[二叉树二叉树(binary tree)是一棵树，其中每个节点都不能有多余两个的子节点。二叉树的一个性质是一颗平均二叉树的深度要比节点个数N小得多，这个性质有时候很重要。 实现因为一个二叉树节点最多有两个子节点，所以可以保存直接链接到它们的链。树节点的声明在结构上类似于双链表的声明，在声明中，节点就是有element的信息加上两个到其他节点的引用(left和right)组成的结构123456class BinaryNode&#123; Object element; BinaryNode left; BinaryNode right;&#125; 例子：表达式树表达式树的树叶是操作数，比如：常数或者变量名，而其他的节点为操作符。由于所有的操作都是二元的，因此这棵树正好是二叉树。如下图： 查找树ADT——二叉查找树二叉树的一个重要应用就是它们在查找中的使用。使二叉树成为查找树的性质是，对于树中的每个节点X，它的左子树中所有想的值小于X中的项，而它右子树中所有项的值大于X中的项。如下图(假设节点元素都是整数)：二叉树查找树要求所有的项都能够排序，需要写出一个interface来标识这个性质，这个接口就是Comparable。该接口告诉我们树种的两项总可以使用compareTo方法进行比较。由此可以确定所有其他可能的关系，特别是不适用equals方法，而是根据两项相等当且仅当compareTo方法返回0来判断相等。 contains方法如果在树T中存在还有项X的节点，那么这个操作需要返回true，如果这样的节点不存在则返回false。 findMin方法和findMax方法这两个private分别返回树中包含最小和最大元素的节点的引用。执行findMin从根开始并且只要有左节点就向左进行，终点就是最小的元素，findMax向右同理。 insert方法为了将X插入到树T中，可以像用contains那样沿着树查找。如果找到X则什么也不做(或者做一些“更新”)，否则将X插入到遍历的路劲上的最后一点上。重复元素的插入可以通过在节点记录中保留一个附加域以指示发生的频率来处理。这对整个树增加了某些附加空间，但是却比将重复信息放到树中要好（它将使树的深度变得很大） remove方法如果节点是一片树叶则立即删除。如果节点有一个子节点，则该节点可以在其父节点调整自己的链以绕过该节点后被删除。如果该节点有两个子节点，一般的删除策略是用其右子树的最小数据代替该节点的数据并递归地删除那个节点(现在它是空的)，因为右子树中的最小的节点不可能有左节点，所以第二次remove要容易。如果删除的次数不多，通常使用的策略是懒惰删除，当一个元素要被删除时，它仍被保留在树中，而是被标记为删除，这在有重复项时很常用，因为此时记录出现频率数的域可以减1. AVL树AVL树是带有平衡条件的二叉查找树。这个平衡条件必须要容易保持，而且它保证树的深度需是O(log N)。最简单的想法是要求左右子树具有相同的高度。另一种平衡条件是要求每个节点都必须有相同高度的左子树和右子树。 单旋转 双旋转 树的遍历遍历的一般方法是首先处理左子树，然后是当前节点，最后是右子树。这个算法的有趣部分除它简单的特性外，还在于其总的运行时间是O(N)。 标准库中的集合与映射List容器即ArrayList和Linkedlist用于查找效率很低。因此,Collections API提供了两个附加容器Set和Map，它们对诸如插入、删除、和查找等基本操作提供有效的实现。 关于Set接口Set接口代表不允许重复元素的Collection。由接口SortedSet给出的一种特殊类型的Set保证其中的各项处于有序的状态。 关于Map接口Map是一个接口，代表由关键字以及它们的值组成的一些项的集合。关键字必须是唯一的，但是若干关键字可以映射到一些相同的值。在SortMap接口中，映射中的关键字保持逻辑上有序的状态。通过一个Map进行迭代要比Colection复杂，因为Map不提供迭代器而是提供3种方法讲Map对象的视图最为Collection对象返回。由于这些视图本身就是Collection，因此它们可以被迭代。如下：123Set&lt;KeyType&gt; keySet()Collection&lt;ValueType&gt; values()Set&lt;Map.Entry&lt;keyType.ValueType&gt;&gt; entrySet() TreeSet类和TreeMap类的实现Java要求TreeSet和TreeMap支持基本的add、remove和contains操作以对数最坏情形时间完成，因此基本的实现方法就是平衡二叉查找树。一般并不适用AVL树，而是使用一些自顶向下的红黑树。 小结表达式树是更一般结构即所谓分析树的一个小例子，分析树是编译器设计中的核心数据结构。分析树不是二叉树，而是表达式树相对简单的扩充。查找树在算法实际中是非常重要的，几乎支持所有有用的操作，而其对数平均开销很小。查找树的问题在于其性能严重依赖输入，而输入是随机的。处理这个问题的几种平衡树方案：AVL数、伸展树、B树等。在实践中，所有平衡树方案的运行时间对于插入和删除操作(除查找稍微快一些)都不如简单二叉树省时，但一般来说是可以接受的，它防止轻易得到最坏情形的输入。通过将一些元素插入到查找树然后执行一次中序遍历，我们得到的是拍过顺序的元素。]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2017%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
