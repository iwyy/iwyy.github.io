<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[优先队列(堆)]]></title>
    <url>%2F2017%2Fpriority-queue%2F</url>
    <content type="text"><![CDATA[优先队列(priority queue)普通的队列是一种先进先出的数据结构，元素在队列尾追加，而从队列头删除。在优先队列中，元素被赋予优先级。当访问元素时，具有最高优先级的元素最先删除。优先队列具有最高级先出 （first in, largest out）的行为特征。 模型优先队列允许至少两种操作的数据结构：insert和deleteMin（删除最小者），它是找出、返回并删除优先队列中最小的元素。insert等价于入队，deleteMin等价出队。 二叉堆结构性质二叉堆是一种特殊的堆，二叉堆是完全填满的二元树（二叉树）或者是近似完全填满的二元树（二叉树）。二叉堆有两种：最大堆和最小堆。最大堆：父结点的键值总是大于或等于任何一个子节点的键值；最小堆：父结点的键值总是小于或等于任何一个子节点的键值。因为完全二叉树很有规律，所以它可以用一个数组标识而不需要使用链。后面始终把堆画成树，具体实现将使用简单的数组一个堆结构将由一个（comparable对象的）数组和一个代表当前堆大小的整数组成。 堆序性质让操作快速执行的性质是堆序性质(heap-order property)。由于想要快速找出最小元素，因此最小元素应该在根上。因此以常数时间得到附加操作findMin。 基本的堆操作所有的工作都需要保证始终保持堆序性质。 insert操作为将一个元素X插入到堆中，在下一个可用位置创建一个空穴，如果X可以放在该空穴中而并不破坏堆的序，那么插入完成。否则，把空穴的父节点上的元素移入该空穴中，这样，空穴就朝着跟的方向向上冒一步，继续该过程直到X能被放入空穴为止。 deleteMin删除根元素，根节点建立一个空穴，将空穴的两个儿子中较小者移入空穴，这样就把空穴乡下推了一层，重复该步骤直到X可以被放入空穴中。需要考虑堆中存在偶数个元素的时候，将遇到一个节点只有一个儿子的情况 优先队列的应用选择问题java标准库中的优先队列未完待续]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[散列]]></title>
    <url>%2F2017%2Fhash%2F</url>
    <content type="text"><![CDATA[散列散列表的实现常常叫做散列(hashing)。散列是一种用于以常数平均时间执行插入、删除和查找的技术。但是，那些需要元素间任何排序信息的树操作将不会得到有效的支持。 散列表散列表（Hash table，也叫哈希表），是根据关键码值(Key value)而直接进行访问的数据结构。也就是说，它通过把关键码值映射到表中一个位置来访问记录，以加快查找的速度。这个映射函数叫做散列函数，存放记录的数组叫做散列表。 哈希函数给定表M，存在函数f(key)，对任意给定的关键字值key，代入函数后若能得到包含该关键字的记录在表中的地址，则称表M为哈希(Hash）表，函数f(key)为哈希(Hash) 函数。所有散列函数都有如下一个基本特性：如果两个散列值是不相同的（根据同一函数），那么这两个散列值的原始输入也是不相同的。这个特性是散列函数具有确定性的结果。但另一方面，散列函数的输入和输出不是一一对应的，如果两个散列值相同，两个输入值很可能是相同的，但不绝对肯定二者一定相等（可能出现哈希碰撞）。输入一些数据计算出散列值，然后部分改变输入值，一个具有强混淆特性的散列函数会产生一个完全不同的散列值。 散列的价值散列的价值在于速度假如键没有按照一定的顺序进行保存，那么查询的时候就只能按照顺序进行线性查询，然而，线性查询是最慢的查询方式。所以，将键值按照一定的顺序排序，并且使用二分查找能购有效的提升速度。散列在此之上，更近一步，他将键保存在数组中(数组的查询速度最快)，用数组来表示键的信息，但是由于Map的容量是可变的，而数组的容量是不变的。要解决这个问题，数组中存的并不是键本身，而是键对象生成的一个数字，将其作为数组的下标，这个数字就是散列码。而这种办法所产生的问题就是下标重复。而我们的解决办法就是配合equals来确定键值。查询的过程首先就是计算散列码，然后用散列码来查询函数(下标)，通常，我们的数组中保存的是值的list，因此，我们计算出散列码之后，通过下表取到的对应部分的list，然后通过equals就可以快速找到键值。 处理冲突方法分离链接法其做法是将散列到同一个值的所有元素保存到一个表中。执行一次查找，使用散列函数来确定究竟遍历哪个链表。然后在被确定的链表中执行一次查找。执行一次插入，检查响应的链表看看该元素是否已经处在适当的位置(如果允许插入重复元素，那么要留出一个额外的域，这个域当出现匹配事件时增1)。如果这个元素是新的元素，那么它将被插入到链表前端，这个不仅因为方便，还因为常常发生这样的事实：新近插入的元素最有可能不久又被访问。除链表外，任何方案都可以解决冲突现象，一颗二叉树或者另一个散列表都可以，但是最好的解决方案是散列函数是最好的，那么所有的链表都应该是短的。 开放定址法分离链接散列算法的缺点是使用一些链表。由于给新单元分配地址需要时间，因此倒着算法的速度有些减慢，同时算法实际上还要求对第二种数据结构的实现。另一种不用链表解决冲突的方法是尝试另外一些单元，知道找出空的单元为止。因为所有大数据都要放入表内，所以这种解决方案所需要的表要比分离链接散列的表大。一般来说对于不适用分离链接的散列表来说其装填因子应该低于0.5，这样的表叫做侦探散列表。这种通常的冲突解决方案有三种。 线性侦探法平均探测法双散列法再散列法对于使平方探测的开放定址散列法，如果散列表填的太满，那么操作的运行时间将开始消耗过长，且插入操作可能失败。此时，一种解决方案是建立另外一个大约两倍的大的表，而且使用一个相关的新散列函数，扫描整个原始散列表，计算每个元素的新散列值并将其插入到新表中，整个操作就是叫做再散列。 java标准库中的散列表标准库包括Set和Map的散列表的实现：HashSet和HashMap类。HashSet中的项必须提供equals和hashCode方法。它们通常是用分离链接散列实现的。散列表操作中费时多的部分就是计算hashCode方法，String类中的hashCode有个重要优化：每个String对象内部都存储它的hashCode值，初始为0，若hashCode方法被调用，那么就记住这个值，ru过hashCode对同一个String对象第二次计算，则可以避免昂贵的重新计算，这个技巧叫做闪存散列代码。闪存散列代码之所以有效，是因为String类是不可改变的：要是String允许变化，那么它就会使hashCode无效，而重置回0. 可扩散列处理数据量太大以至于装不进主存的情况。 查找性能分析散列表的查找过程基本上和造表过程相同。一些关键码可通过散列函数转换的地址直接找到，另一些关键码在散列函数得到的地址上产生了冲突，需要按处理冲突的方法进行查找。在介绍的三种处理冲突的方法中，产生冲突后的查找仍然是给定值与关键码进行比较的过程。所以，对散列表查找效率的量度，依然用平均查找长度来衡量。查找过程中，关键码的比较次数，取决于产生冲突的多少，产生的冲突少，查找效率就高，产生的冲突多，查找效率就低。因此，影响产生冲突多少的因素，也就是影响查找效率的因素。影响产生冲突多少有以下三个因素：1．散列函数是否均匀； 处理冲突的方法；3．散列表的装填因子。散列表的装填因子定义为：α= 填入表中的元素个数/散列表的长度α是散列表装满程度的标志因子。由于表长是定值，α与“填入表中的元素个数”成正比，所以，α越大，填入表中的元素较多，产生冲突的可能性就越大；α越小，填入表中的元素较少，产生冲突的可能性就越小。实际上，散列表的平均查找长度是装填因子α的函数，只是不同处理冲突的方法有不同的函数。常用hash算法：（1)MD4（2)MD5（3)SHA-1及其他]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[表、栈和队列]]></title>
    <url>%2F2017%2Flist%2F</url>
    <content type="text"><![CDATA[ADT抽象数据类型(abstract data type,ADT)是带有一组操作的对象的集合。对于集合ADT，可以有添加、删除、包含等操作 表ADT简单数组实现对表的所有操作都可以通过使用数组来实现。虽然数组是有固定容量创建的，但在需要的时候可以使用双倍的容量创建一个不同的数组。许多情形下表是通过在末端进行插入操作的，然后只对数组访问。这种情形下数组是一种恰当的实现。然而如果发生一些插入和删除操作，特别是前端进行，那么数组不是一种好的选择。 简单链表为了避免插入和删除的线性开销，需要保证表可以不连续存储，否则表的每个部分都可能需要整体移动。链表是由一系列的节点组成，这些节点不必在内存中相连，每个节点含有表元素和到包含该元素后继元素的节点的链，可以称之为next链，最后一个单元的next链引用null。简单链表删除最后一项比较复杂，因为必须找出指向最后节点的项，把它的next链改成null，然后在更新持有最后节点的链，最好的做法是让每一个节点有一个指向它在表中的前面节点的链称之为双链表 java Collection API中的表Collection接口 Collection接口扩展了Iterable接口，实现Iterable接口的类拥有增强for循环，都可以使用forEach进行循环遍历123456789public interface Collection&lt;E&gt; extends Iterable&lt;E&gt; &#123; int size(); boolean isEmpty(); void clear(); boolean contains(Object o); Iterator&lt;E&gt; iterator(); boolean add(E e); boolean remove(Object o); &#125; Iterator接口1234567public interface Iterator&lt;E&gt; &#123; boolean hasNext(); E next(); default void remove() &#123; throw new UnsupportedOperationException(&quot;remove&quot;); &#125;&#125; Iterator的remove方法主要优点在于：Collection的remove方法必须先找出需要删除的项。在迭代集合时Collection的remove会抛出ConcurrentModificationException 增强for循环java中的增强for循环实际上编译器会重写成如下所示：1234567891011List&lt;String&gt; list = new ArrayList&lt;&gt;();list.add("abc");for (String s : list) &#123; System.out.println(s);&#125;//等同于上面增强for循环写法Iterator&lt;String&gt; it = list.iterator();while (it.hasNext()) &#123; String s = it.next(); System.out.println(s);&#125; List接口、ArrayList类和LinkedList类1、ArrayList类提供了list ADT的一种可增长数组的实现，其优点在于对get和set的调用花费常数时间，其缺点是插入和删除代价昂贵（除了在末端进行）。2、LinkedList类提供了list ADT的双链表实现，其优点是插入和删除均开销很小，在表的前端和末端添加和删除都是常数时间的操作，其缺点是不容易索引，get的调用是昂贵的（除了get第一个和最后一个）。3、对搜索而言，ArrayList和LinkedList都是低效的，对Collection的contains和remove方法的调用均花费线性时间。4、ArrayList中有个容量的概念，它标识基础数组的大小，在需要的时候会自动扩容保证至少具有表的大小，如果早期知道该大小，可以设置容量足够大的量以避免数组容量以后的扩展，trimToSize可以在所有的ArrayList添加操作完成之后使用以避免浪费空间。5、以下方法对于LinkedList操作整个程序线性时间不是二次时间，对于ArrayList是二次时间，因为对于ArrayList即使迭代器位于需要被删除的节点上，其remove方法仍然是昂贵的，因为数组的项必须要移动12345678public static void remove(List&lt;Integer&gt; list) &#123; Iterator&lt;Integer&gt; iterator = list.iterator(); while (iterator.hasNext()) &#123; if (iterator.next() % 2 == 0) &#123; iterator.remove(); &#125; &#125; &#125; ListIterator接口ListIterator扩展了Iterator接口。1、iterator可以应用于所有的集合，Set、List和Map以及这些集合的子类型。而ListIterator只能用于List及其子类型。2、ListIterator有hasPrevious()和previous()方法，可以实现逆向遍历，但是iterator不可以。3、ListIterator可以定位当前索引的位置，nextIndex()和previousIndex()可以实现。Iterator没有此功能。4、ListIterator有add方法，可以向List中添加对象，而Iterator不能。5、ListIterator可以实现对象的修改，set()方法可以实现。Iterator仅能遍历，不能实现修改。都可以实现删除操作。用例：它可以用来从List的所有的偶数中减去1，对于LinkedList来说，不适用ListIterator的set方法是很难做到的。 简单的ArrayList类的实现只供参考理解，编译器会报错123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111public class MyArrayList&lt;AnyType&gt; implements Iterable&lt;AnyType&gt; &#123; private static final int DEFAULT_CAPACITY = 10; private int theSize; private AnyType[] theItems; public int size() &#123; return theSize; &#125; public boolean isEmpty() &#123; return size() == 0; &#125; //调整容量符合大小 public void trimToSize() &#123; ensureCapacity(size()); &#125; //确保数组大小足够大 public void ensureCapacity(int newCapacity) &#123; if(newCapacity &lt; theSize) return; //复制数据到新数组中 AnyType[] old = theItems; theItems = (AnyType[]) new Object[newCapacity]; for(int i = 0; i &lt;size(); i++) &#123; theItems[i] = old[i]; &#125; &#125; public AnyType get(int index) &#123; if(index &lt; 0 || index &gt;= size()) &#123; throw new ArrayIndexOutOfBoundsException(); &#125; return theItems[index]; &#125; public AnyType set(int index, AnyType newVal) &#123; if(index &lt; 0 || index &gt;= size()) &#123; throw new ArrayIndexOutOfBoundsException(); &#125; AnyType old = theItems[index]; theItems[index] = newVal; return old; &#125; public void add(int index, AnyType x) &#123; //数组不够大，则扩大数组 if(theItems.length == size()) &#123; ensureCapacity(size()*2 + 1); &#125; //从index开始，元素往后移动一位 for(int i = theSize; i &gt; index; i--) &#123; theItems[i] = theItems[i - 1]; &#125; //index位置赋值x theItems[index] = x; theSize++; &#125; public AanyType remove(int index) &#123; AnyType removedItem = theItems[index]; for(int i = index; i &lt; size(); i++) &#123; //从index位置开始，所有元素都往前移动一位 theItems[i] = theItems[i + 1]; &#125; theSize--; return removedItem; &#125; public java.util.Iterator&lt;AnyType&gt; iterator() &#123; return new ArrayListIterator&lt;AnyType&gt;(); &#125; private static class ArrayListIterator&lt;AnyType&gt; implements java.util.Iterator&lt;AnyType&gt; &#123; private int current = 0; public boolean hasNext() &#123; return current &lt; MyArrayList.this.size(); &#125; public AnyType next() &#123; return MyArrayList.this.theItems[current++]; &#125; public void remove() &#123; //防止迭代器的remove与MyArrayList的remove冲突 MyArrayList.this.remove(--current); &#125; &#125; &#125;; 简单的LinkedList类的实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176public class MyLinkedList &lt;AnyType&gt; implements Iterable&lt;AnyType&gt;&#123; private int theSize; //双向链表中的元素个数 private int modCount; //这个标记为了配合Iterator实现修改的保护，这一点后面专做论述,凡是做了增删修改，这个标记均变化 private Node&lt;AnyType&gt; beginMarker; // 双向链表的开始标记 private Node&lt;AnyType&gt; endMarker; //双向链表的尾部标记 public MyLinkedList() &#123; // 构造函数 先初始化双向聊表 调动 clear()函数 clear(); &#125; public void clear() &#123;// 确保双向链表处于空的状态 ----&gt; 我们使用一个辅助的头结点 // 头标记和尾标记 指向同一个 辅助头结点,和一个辅助的尾节点 beginMarker = new Node&lt;AnyType&gt;(null, null, null); endMarker = new Node&lt;AnyType&gt;(null, beginMarker, null); beginMarker.next = endMarker; theSize = 0; modCount ++; //zhege &#125; // 获取元素的个数 public int size() &#123; return theSize; &#125; // 判断是否为空 public boolean isEmpty() &#123; return theSize == 0; &#125; /* * 增删查改的操作 */ // 默认把元素插入到尾部,其中调用插入到指定位置的函数 public boolean add(AnyType x) &#123; add(size()+1, x); return true; &#125; // 把元素插入到指定位置，其中调用插入到指定元素之前 函数 public void add(int idx, AnyType x) &#123; addBefore(getNode(idx), x); &#125; // 重置某个节点的data值，并返回以前的 data值 public AnyType set(int idx, AnyType newVal) &#123; if(idx &lt;1 || idx &gt;size()) throw new RuntimeException(new Exception("下表越界")); Node&lt;AnyType&gt; p = getNode(idx); AnyType oldVal = p.data; p.data = newVal; return oldVal; &#125; // 删除第idx个节点,调用remove(Node)函数，返回删除节点的data值 public AnyType remove(int idx) &#123; if(idx &lt;1 || idx &gt;size()) throw new RuntimeException(new Exception("下表越界")); return remove(getNode(idx)); &#125; /* * 下面这些函数都是一些private的都是位别的一些函数服务的 */ // 在p前面插入 x 元素 private void addBefore(Node&lt;AnyType&gt;p, AnyType x) &#123; Node&lt;AnyType&gt; newNode = new Node&lt;AnyType&gt;(x, p.prev, p); newNode.prev.next = newNode; p.prev = newNode; theSize ++; //添加进来一个新元素之后，别忘了元素个数++ modCount ++; //无论增删 该标志 均++ &#125; // 获取 idx处的 节点引用 private Node&lt;AnyType&gt; getNode(int idx) &#123; if(idx &lt; 1 || idx &gt; size()+1)// 考虑在尾部插入的情况，如果取这个尾节点，其data = null throw new RuntimeException(new Exception("索引越界")); Node&lt;AnyType&gt; p = null; if( idx &lt;= size()/2) // 在前半边中找 &#123; p = beginMarker.next; for( int i = 1; i &lt; idx; i++) p = p.next; &#125;else&#123; //在后半边中找 p = endMarker; for(int i = size(); i &gt;= idx; i--) p = p.prev; &#125; return p; &#125; // 返回 删除某个节点，并返回这个节点的data值 private AnyType remove(Node&lt;AnyType&gt; p) &#123; p.prev.next = p.next; p.next.prev = p.prev; theSize --; modCount --; return p.data; &#125; /* * 实现迭代器 */ public Iterator&lt;AnyType&gt; iterator() &#123; return new LinkedListIterator(); &#125; //实现迭代器 private class LinkedListIterator implements Iterator&lt;AnyType&gt; &#123; private Node&lt;AnyType&gt; current = beginMarker.next; //记住当前的位置，这和书序表中类似 private int expectedModCount = modCount; private boolean okToRemove = false; @Override public boolean hasNext() &#123; // TODO Auto-generated method stub return current!=endMarker; &#125; @Override public AnyType next() &#123; // 注意了 下面的 保护迭代期间 不允许 越过迭代器修改集合元素的 机制 是精髓 if(modCount != expectedModCount) throw new RuntimeException(new Exception("您刚刚越过迭代器修改了集合元素")); if(!hasNext()) throw new RuntimeException(new Exception("已经没有元素了")); AnyType nextItem = current.data; current = current.next; okToRemove = true; return nextItem; &#125; @Override public void remove() &#123; // TODO Auto-generated method stub if(modCount != expectedModCount) throw new RuntimeException(new Exception("您刚刚越过迭代器修改了集合元素")); if(!okToRemove) throw new RuntimeException(new Exception("先next再删除")); MyLinkedList.this.remove(current.prev); okToRemove = false; // 与next()中的 okToRemove = false； 遥相呼应，以确保必须在next()之后才能remove expectedModCount ++; &#125; &#125; /* * 私有嵌套类的形式，定义内部节点，节点里面没有访问双向链表中的内容，所以使用私有嵌套类可也 * 如果访问了外面类的属性或者方法就只能使用内部类，去除static关键字,内部类的使用主要是为了可以简写，见单链表中的介绍 */ private static class Node&lt;AnyType&gt;&#123; // 构造函数 public Node(AnyType d, Node&lt;AnyType&gt;p, Node&lt;AnyType&gt;n) &#123; data = d; prev = p; next = n; &#125; public AnyType data; public Node&lt;AnyType&gt; prev; public Node&lt;AnyType&gt; next; &#125; &#125; 栈栈(stack)是限制插入和删除只能在一个位置上进行的表，该位置是表的末端，叫做栈的顶端(top),对栈的操作有push(进栈)和pop(出栈)，前者相对于插入，后者相对于删除最后插入的元素。栈有时又叫做LIFO(后进先出)表。 栈的实现由于栈是一个表，任何实现表的方法都能实现栈，ArrayList和LinkedList都支持栈操作 栈的应用简单例子：平衡符号：编译器检查程序的语法错误叙述如下：做一个空栈，读入字符知道文件结尾，如果字符是个开放符号则将其推入栈中，如果是个封闭符号则当栈空时报错，否则将栈元素弹出，如果弹出的符号不是对应的开放符号则报错，在文件结尾如果栈非空则报错。 队列队列也是表，使用队列时，插入在一段，删除则在另一端。队列的基本操作是enqueue(入队)，它在表的末端插入元素，和dequeue(出队)，它删除并返回在表的开头的元素 队列的实现如果栈的情形一样，对于队列而言任何的表的实现都是合法的 队列的应用窗口买票的应用等所有需要先进先出的案例]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[树]]></title>
    <url>%2F2017%2Ftree%2F</url>
    <content type="text"><![CDATA[二叉树二叉树(binary tree)是一棵树，其中每个节点都不能有多余两个的子节点。二叉树的一个性质是一颗平均二叉树的深度要比节点个数N小得多，这个性质有时候很重要。 实现因为一个二叉树节点最多有两个子节点，所以可以保存直接链接到它们的链。树节点的声明在结构上类似于双链表的声明，在声明中，节点就是有element的信息加上两个到其他节点的引用(left和right)组成的结构123456class BinaryNode&#123; Object element; BinaryNode left; BinaryNode right;&#125; 例子：表达式树表达式树的树叶是操作数，比如：常数或者变量名，而其他的节点为操作符。由于所有的操作都是二元的，因此这棵树正好是二叉树。如下图： 查找树ADT——二叉查找树二叉树的一个重要应用就是它们在查找中的使用。使二叉树成为查找树的性质是，对于树中的每个节点X，它的左子树中所有想的值小于X中的项，而它右子树中所有项的值大于X中的项。如下图(假设节点元素都是整数)：二叉树查找树要求所有的项都能够排序，需要写出一个interface来标识这个性质，这个接口就是Comparable。该接口告诉我们树种的两项总可以使用compareTo方法进行比较。由此可以确定所有其他可能的关系，特别是不适用equals方法，而是根据两项相等当且仅当compareTo方法返回0来判断相等。 contains方法如果在树T中存在还有项X的节点，那么这个操作需要返回true，如果这样的节点不存在则返回false。 findMin方法和findMax方法这两个private分别返回树中包含最小和最大元素的节点的引用。执行findMin从根开始并且只要有左节点就向左进行，终点就是最小的元素，findMax向右同理。 insert方法为了将X插入到树T中，可以像用contains那样沿着树查找。如果找到X则什么也不做(或者做一些“更新”)，否则将X插入到遍历的路劲上的最后一点上。重复元素的插入可以通过在节点记录中保留一个附加域以指示发生的频率来处理。这对整个树增加了某些附加空间，但是却比将重复信息放到树中要好（它将使树的深度变得很大） remove方法如果节点是一片树叶则立即删除。如果节点有一个子节点，则该节点可以在其父节点调整自己的链以绕过该节点后被删除。如果该节点有两个子节点，一般的删除策略是用其右子树的最小数据代替该节点的数据并递归地删除那个节点(现在它是空的)，因为右子树中的最小的节点不可能有左节点，所以第二次remove要容易。如果删除的次数不多，通常使用的策略是懒惰删除，当一个元素要被删除时，它仍被保留在树中，而是被标记为删除，这在有重复项时很常用，因为此时记录出现频率数的域可以减1. AVL树AVL树是带有平衡条件的二叉查找树。这个平衡条件必须要容易保持，而且它保证树的深度需是O(log N)。最简单的想法是要求左右子树具有相同的高度。另一种平衡条件是要求每个节点都必须有相同高度的左子树和右子树。 单旋转 双旋转 树的遍历遍历的一般方法是首先处理左子树，然后是当前节点，最后是右子树。这个算法的有趣部分除它简单的特性外，还在于其总的运行时间是O(N)。 标准库中的集合与映射List容器即ArrayList和Linkedlist用于查找效率很低。因此,Collections API提供了两个附加容器Set和Map，它们对诸如插入、删除、和查找等基本操作提供有效的实现。 关于Set接口Set接口代表不允许重复元素的Collection。由接口SortedSet给出的一种特殊类型的Set保证其中的各项处于有序的状态。 关于Map接口Map是一个接口，代表由关键字以及它们的值组成的一些项的集合。关键字必须是唯一的，但是若干关键字可以映射到一些相同的值。在SortMap接口中，映射中的关键字保持逻辑上有序的状态。通过一个Map进行迭代要比Colection复杂，因为Map不提供迭代器而是提供3种方法讲Map对象的视图最为Collection对象返回。由于这些视图本身就是Collection，因此它们可以被迭代。如下：123Set&lt;KeyType&gt; keySet()Collection&lt;ValueType&gt; values()Set&lt;Map.Entry&lt;keyType.ValueType&gt;&gt; entrySet() TreeSet类和TreeMap类的实现Java要求TreeSet和TreeMap支持基本的add、remove和contains操作以对数最坏情形时间完成，因此基本的实现方法就是平衡二叉查找树。一般并不适用AVL树，而是使用一些自顶向下的红黑树。 小结表达式树是更一般结构即所谓分析树的一个小例子，分析树是编译器设计中的核心数据结构。分析树不是二叉树，而是表达式树相对简单的扩充。查找树在算法实际中是非常重要的，几乎支持所有有用的操作，而其对数平均开销很小。查找树的问题在于其性能严重依赖输入，而输入是随机的。处理这个问题的几种平衡树方案：AVL数、伸展树、B树等。在实践中，所有平衡树方案的运行时间对于插入和删除操作(除查找稍微快一些)都不如简单二叉树省时，但一般来说是可以接受的，它防止轻易得到最坏情形的输入。通过将一些元素插入到查找树然后执行一次中序遍历，我们得到的是拍过顺序的元素。]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2017%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
